import { EnumOperandDirection } from "../enums/EnumOperandDirection";
import { EnumRuleNodeType } from "../enums/EnumRuleNodeType";
import { IOperandDefinition } from "../interfaces/IOperandDefinition";

export class CurrentOperandDefinitions {
    static OperandDefinitions: IOperandDefinition[] = [
        { OperandRegexStr: "\\(", OperandParRegexStr: "\\(([^()]*)\\)", Precedence: 1, Key: "()", Direction: EnumOperandDirection.LeftToRight, ThereIsLeftParameter: false, ThereIsRighParameter: false, IsGrouping: true, Description: "Grouping" },
        { OperandRegexStr: "\\s+in\\s+", OperandParRegexStr: "(«?\\w+»?)\\s+in\\s+(«\\w+»)", Precedence: 2, Key: "in (...)", Enum: EnumRuleNodeType.In, Direction: EnumOperandDirection.LeftToRight, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "In", },
        { OperandRegexStr: "\\s+not\\s+in\\s+", OperandParRegexStr: "(«?\\w+»?)\\s+not\\s+in\\s+(«\\w+»)", Precedence: 2, Key: "not in (...)", Enum: EnumRuleNodeType.NotIn, Direction: EnumOperandDirection.LeftToRight, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Not In", },
        { OperandRegexStr: "!", OperandParRegexStr: "!(«?\\w+»?)", Precedence: 3, Key: "!", Enum: EnumRuleNodeType.LogicalNot, Direction: EnumOperandDirection.LeftToRight, ThereIsLeftParameter: false, ThereIsRighParameter: true, Description: "Logical NOT", },
        { OperandRegexStr: "\\*\\*", OperandParRegexStr: "(«?\\w+»?)\\s*\\*\\*\\s*(«?\\w+»?)", Precedence: 4, Key: "**", Enum: EnumRuleNodeType.Exponentiation, Direction: EnumOperandDirection.LeftToRight, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Exponentiation", },
        { OperandRegexStr: "\\*", OperandParRegexStr: "(«?\\w+»?)\\s*\\*\\s*(«?\\w+»?)", Precedence: 5, Key: "*", Enum: EnumRuleNodeType.Multiply, Direction: EnumOperandDirection.LeftToRight, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Multiplication", },
        { OperandRegexStr: "/", OperandParRegexStr: "(«?\\w+»?)\\s*/\\s*(«?\\w+»?)", Precedence: 5, Key: "/", Enum: EnumRuleNodeType.Divide, Direction: EnumOperandDirection.LeftToRight, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Division", },
        { OperandRegexStr: "%", OperandParRegexStr: "(«?\\w+»?)\\s*%\\s*(«?\\w+»?)", Precedence: 5, Key: "%", Enum: EnumRuleNodeType.Remainder, Direction: EnumOperandDirection.LeftToRight, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Remainder", },
        { OperandRegexStr: "\\+", OperandParRegexStr: "(«?\\w+»?)\\s*\\+\\s*(«?\\w+»?)", Precedence: 6, Key: "+", Enum: EnumRuleNodeType.Plus, Direction: EnumOperandDirection.LeftToRight, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Addition", },
        { OperandRegexStr: "-", OperandParRegexStr: "(«?\\w+»?)\\s*-\\s*(«?\\w+»?)", Precedence: 6, Key: "-", Enum: EnumRuleNodeType.Minus, Direction: EnumOperandDirection.LeftToRight, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Subtraction", },
        { OperandRegexStr: "<", OperandParRegexStr: "(«?\\w+»?)\\s*<\\s*(«?\\w+»?)", Precedence: 7, Key: "<", Enum: EnumRuleNodeType.SmallerThan, Direction: EnumOperandDirection.LeftToRight, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Less Than", },
        { OperandRegexStr: "<=", OperandParRegexStr: "(«?\\w+»?)\\s*<=\\s*(«?\\w+»?)", Precedence: 7, Key: "<=", Enum: EnumRuleNodeType.SmallerOrEqualThan, Direction: EnumOperandDirection.LeftToRight, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Less Than Or Equal", },
        { OperandRegexStr: ">", OperandParRegexStr: "(«?\\w+»?)\\s*>\\s*(«?\\w+»?)", Precedence: 7, Key: ">", Enum: EnumRuleNodeType.BiggerThan, Direction: EnumOperandDirection.LeftToRight, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Greater Than", },
        { OperandRegexStr: ">=", OperandParRegexStr: "(«?\\w+»?)\\s*>=\\s*(«?\\w+»?)", Precedence: 7, Key: ">=", Enum: EnumRuleNodeType.BiggerOrEqualThan, Direction: EnumOperandDirection.LeftToRight, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Greater Than Or Equal", },
        { OperandRegexStr: "==", OperandParRegexStr: "(«?\\w+»?)\\s*==\\s*(«?\\w+»?)", Precedence: 8, Key: "==", Enum: EnumRuleNodeType.Equal, Direction: EnumOperandDirection.LeftToRight, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Equality", },
        { OperandRegexStr: "!=", OperandParRegexStr: "(«?\\w+»?)\\s*!=\\s*(«?\\w+»?)", Precedence: 8, Key: "!=", Enum: EnumRuleNodeType.NotEqual, Direction: EnumOperandDirection.LeftToRight, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Inequality", },
        { OperandRegexStr: "===", OperandParRegexStr: "(«?\\w+»?)\\s*===\\s*(«?\\w+»?)", Precedence: 8, Key: "===", Enum: EnumRuleNodeType.StrictEqual, Direction: EnumOperandDirection.LeftToRight, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Strict Equality", },
        { OperandRegexStr: "!==", OperandParRegexStr: "(«?\\w+»?)\\s*!==\\s*(«?\\w+»?)", Precedence: 8, Key: "!==", Enum: EnumRuleNodeType.StrictNotEqual, Direction: EnumOperandDirection.LeftToRight, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Strict Inequality", },
        { OperandRegexStr: "&", OperandParRegexStr: "(«?\\w+»?)\\s*&\\s*(«?\\w+»?)", Precedence: 9, Key: "&", Enum: EnumRuleNodeType.BitwiseAnd, Direction: EnumOperandDirection.LeftToRight, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Bitwise AND", },
        { OperandRegexStr: "\\^", OperandParRegexStr: "(«?\\w+»?)\\s*\\^\\s*(«?\\w+»?)", Precedence: 10, Key: "^", Enum: EnumRuleNodeType.BitwiseXor, Direction: EnumOperandDirection.LeftToRight, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Bitwise XOR", },
        { OperandRegexStr: "\\|", OperandParRegexStr: "(«?\\w+»?)\\s*\\|\\s*(«?\\w+»?)", Precedence: 11, Key: "|", Enum: EnumRuleNodeType.BitwiseOr, Direction: EnumOperandDirection.LeftToRight, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Bitwise OR", },
        { OperandRegexStr: "&&", OperandParRegexStr: "(«?\\w+»?)\\s*&&\\s*(«?\\w+»?)", Precedence: 12, Key: "&&", Enum: EnumRuleNodeType.LogicalAnd, Direction: EnumOperandDirection.LeftToRight, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Logical AND", },
        { OperandRegexStr: "\\|\\|", OperandParRegexStr: "(«?\\w+»?)\\s*\\|\\|\\s*(«?\\w+»?)", Precedence: 13, Key: "||", Enum: EnumRuleNodeType.LogicalOr, Direction: EnumOperandDirection.LeftToRight, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Logical OR", },
        { OperandRegexStr: "=", OperandParRegexStr: "(«?\\w+»?)\\s*=\\s*(«?\\w+»?)", Precedence: 14, Key: "=", Enum: EnumRuleNodeType.Assignment, Direction: EnumOperandDirection.RightToLeft, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Assignment", },
        { OperandRegexStr: "\\+=", OperandParRegexStr: "(«?\\w+»?)\\s*\\+=\\s*(«?\\w+»?)", Precedence: 14, Key: "+=", Enum: EnumRuleNodeType.PlusAssignment, Direction: EnumOperandDirection.RightToLeft, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Assignment", },
        { OperandRegexStr: "-=", OperandParRegexStr: "(«?\\w+»?)\\s*-=\\s*(«?\\w+»?)", Precedence: 14, Key: "-=", Enum: EnumRuleNodeType.MinusAssignment, Direction: EnumOperandDirection.RightToLeft, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Assignment", },
        { OperandRegexStr: "\\*\\*=", OperandParRegexStr: "(«?\\w+»?)\\s*\\*\\*=\\s*(«?\\w+»?)", Precedence: 14, Key: "**=", Enum: EnumRuleNodeType.ExponentiationAssignment, Direction: EnumOperandDirection.RightToLeft, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Assignment", },
        { OperandRegexStr: "\\*=", OperandParRegexStr: "(«?\\w+»?)\\s*\\*=\\s*(«?\\w+»?)", Precedence: 14, Key: "*=", Enum: EnumRuleNodeType.MultiplyAssignment, Direction: EnumOperandDirection.RightToLeft, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Assignment", },
        { OperandRegexStr: "/=", OperandParRegexStr: "(«?\\w+»?)\\s*/=\\s*(«?\\w+»?)", Precedence: 14, Key: "/=", Enum: EnumRuleNodeType.DivideAssignment, Direction: EnumOperandDirection.RightToLeft, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Assignment", },
        { OperandRegexStr: "%=", OperandParRegexStr: "(«?\\w+»?)\\s*%=\\s*(«?\\w+»?)", Precedence: 14, Key: "%=", Enum: EnumRuleNodeType.RemainderAssignment, Direction: EnumOperandDirection.RightToLeft, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Assignment", },
        { OperandRegexStr: "&=", OperandParRegexStr: "(«?\\w+»?)\\s*&=\\s*(«?\\w+»?)", Precedence: 14, Key: "&=", Enum: EnumRuleNodeType.BitwiseAndAssignment, Direction: EnumOperandDirection.RightToLeft, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Assignment", },
        { OperandRegexStr: "\\^=", OperandParRegexStr: "(«?\\w+»?)\\s*\\^=\\s*(«?\\w+»?)", Precedence: 14, Key: "^=", Enum: EnumRuleNodeType.BitwiseXorAssignment, Direction: EnumOperandDirection.RightToLeft, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Assignment", },
        { OperandRegexStr: "\\|=", OperandParRegexStr: "(«?\\w+»?)\\s*\\|=\\s*(«?\\w+»?)", Precedence: 14, Key: "|=", Enum: EnumRuleNodeType.BitwiseOrAssignment, Direction: EnumOperandDirection.RightToLeft, ThereIsLeftParameter: true, ThereIsRighParameter: true, Description: "Assignment", },
    ];

    static FindOperandDefinitions(enumRuleNodeType: EnumRuleNodeType): IOperandDefinition | undefined {
        const findResult = this.OperandDefinitions.find(o => o.Enum === enumRuleNodeType);
        return findResult;
    }
}


